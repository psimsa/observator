using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Observator.Generator;

public static class SourceCodeGenerator
{
    public static string Generate(Dictionary<string, Dictionary<string, List<MethodInterceptorInfo>>> interceptorsByNamespace, string assemblyName)
    {
        var sb = new StringBuilder();
        sb.AppendLine(ObservatorConstants.AutoGeneratedComment);

        foreach (var nsGroup in interceptorsByNamespace)
        {
            var ns = nsGroup.Key;
            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");
            }

            sb.AppendLine(ObservatorConstants.InterceptorClassName);
            sb.AppendLine("{");

            foreach (var methodGroup in nsGroup.Value)
            {
                sb.Append(GenerateMethodCode(methodGroup.Value, assemblyName));
            }

            sb.AppendLine("}");
            if (!string.IsNullOrEmpty(ns))
            {
                sb.AppendLine("}");
            }
        }

        sb.AppendLine(ObservatorConstants.CompilerServicesNamespace);
        sb.AppendLine("{");
        sb.AppendLine($"    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
        sb.AppendLine($"    file sealed class {ObservatorConstants.InterceptsLocationAttributeName}(int version, string data) : Attribute {{ }}");
        sb.AppendLine("}");

        return sb.ToString();
    }

    // Extracted helper for method code generation
    private static string GenerateMethodCode(List<MethodInterceptorInfo> callList, string assemblyName)
    {
        if (callList == null || callList.Count == 0)
            return string.Empty;

        var method = callList[0].MethodSymbol;
        var returnType = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = method.Name;
        var parameters = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.Name}"));
        var args = string.Join(", ", method.Parameters.Select(p => p.Name));
        var isAsync = method.ReturnType.Name == ObservatorConstants.TaskReturnType || method.ReturnType.Name == ObservatorConstants.ValueTaskReturnType;
        var asyncModifier = isAsync ? "async " : "";

        var sb = new StringBuilder();
        foreach (var call in callList)
        {
            sb.AppendLine($"    [System.Runtime.CompilerServices.InterceptsLocationAttribute({call.Location.Version}, \"{call.Location.Data}\")]");
        }

        string thisType = callList[0].IsInterfaceMethod
            ? callList[0].MethodSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            : method.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        sb.AppendLine($"    public static {asyncModifier}{returnType} Intercepts{methodName}(this {thisType} @source{(parameters.Length > 0 ? ", " + parameters : "")})");
        sb.AppendLine(GenerateInterceptorBody_Extension(methodName, args, isAsync, assemblyName));

        return sb.ToString();
    }

    private static string GenerateInterceptorBody_Extension(string methodName, string args, bool isAsync, string assemblyName)
    {
        var awaitPrefix = isAsync ? "await " : "";
        var returnPrefix = isAsync || !string.IsNullOrEmpty(args) ? "return " : "";
        var result = new StringBuilder();
        result.AppendLine("    {");
        result.AppendLine($"        using var activity = System.Diagnostics.Activity.Current?.Source.StartActivity($\"{ObservatorConstants.ActivityNameFormat.Replace("{methodName}", methodName)}\");");
        result.AppendLine("        try");
        result.AppendLine("        {");
        result.AppendLine($"            {returnPrefix}{awaitPrefix}@source.{methodName}({args});");
        result.AppendLine("        }");
        result.AppendLine("        catch (Exception exception)");
        result.AppendLine("        {");
        result.AppendLine(ObservatorConstants.ActivitySetStatusError);
        result.AppendLine("            throw;");
        result.AppendLine("        }");
        result.AppendLine("        finally");
        result.AppendLine("        {");
        result.AppendLine(ObservatorConstants.ActivitySetStatusOk);
        result.AppendLine("        }");
        result.AppendLine("    }");
        return result.ToString();
    }
}