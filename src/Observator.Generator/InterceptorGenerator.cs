using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Observator.Generator
{
    [Generator]
    public class InterceptorGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for now
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // 1. Discover all methods decorated with [ObservatorTrace]
            var attributedMethods = new List<(IMethodSymbol symbol, MethodDeclarationSyntax syntax)>();
            var traceAttributeFullName = "Observator.Generated.ObservatorTraceAttribute";
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var methodDeclarations = syntaxTree.GetRoot()
                    .DescendantNodes()
                    .OfType<MethodDeclarationSyntax>();
                foreach (var methodDecl in methodDeclarations)
                {
                    var methodSymbol = semanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
                    if (methodSymbol == null) continue;
                    foreach (var attr in methodSymbol.GetAttributes())
                    {
                        var attrClass = attr.AttributeClass;
                        if (attrClass == null) continue;
                        var attrName = attrClass.Name;
                        var attrFullName = attrClass.ToDisplayString();
                        if ((attrFullName == traceAttributeFullName ||
                            attrName == "ObservatorTraceAttribute" ||
                            attrName == "ObservatorTrace"))
                        {
                            if (methodSymbol.IsAbstract)
                            {
                                // Optionally, emit a diagnostic here for user feedback
                                // context.ReportDiagnostic(Diagnostic.Create(...));
                                continue; // Skip abstract methods
                            }
                            attributedMethods.Add((methodSymbol, methodDecl));
                            break;
                        }
                    }
                }
            }

            // 2. For each attributed method, find all call sites
            var callSites = new List<(IMethodSymbol method, MethodDeclarationSyntax syntax, Location location, SyntaxNode invocation)>();
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var invocations = syntaxTree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>();
                foreach (var invocation in invocations)
                {
                    var symbolInfo = semanticModel.GetSymbolInfo(invocation);
                    var targetMethod = symbolInfo.Symbol as IMethodSymbol;
                    if (targetMethod == null) continue;
                    foreach (var (attributed, syntax) in attributedMethods)
                    {
                        // Compare by original definition and containing type
                        if (SymbolEqualityComparer.Default.Equals(targetMethod.OriginalDefinition, attributed.OriginalDefinition) &&
                            SymbolEqualityComparer.Default.Equals(targetMethod.ContainingType, attributed.ContainingType))
                        {
                            callSites.Add((attributed, syntax, invocation.GetLocation(), invocation));
                            break;
                        }
                    }
                }
            }

            // 3. Output discovered methods and call sites as a comment in generated code
            var source = "// <auto-generated />\n";
            source += $"// Trace attribute full name: {traceAttributeFullName}\n";
            source += $"// Attributed methods found: {attributedMethods.Count}\n";
            source += "// Discovered attributed methods:\n";
            foreach (var (method, syntax) in attributedMethods)
            {
                source += $"// {method.ContainingType.ToDisplayString()}.{method.Name} ({method.Locations.FirstOrDefault()?.GetLineSpan().Path})\n";
            }
            source += $"// Call sites found: {callSites.Count}\n";
            source += "// Discovered call sites:\n";
            foreach (var (method, syntax, location, invocation) in callSites)
            {
                var span = location.GetLineSpan();
                source += $"// {method.ContainingType.ToDisplayString()}.{method.Name} called at {span.Path}:{span.StartLinePosition.Line + 1},{span.StartLinePosition.Character + 1}\n";
            }

            // 4. Generate using directives first
            source += "using System;\nusing System.Runtime.CompilerServices;\n";
            var classGroups = callSites.GroupBy(cs => cs.method.ContainingType);
            foreach (var classGroup in classGroups)
            {
                var classSymbol = classGroup.Key;
                var className = classSymbol.Name;
                var classNamespace = classSymbol.ContainingNamespace.ToDisplayString();
                // Open namespace
                source += $"namespace {classNamespace}\n{{\n";
                // Emit partial class
                source += $"    public partial class {className}\n    {{\n";
                int idx = 0;
                // Track which _Original methods have been emitted
                var emittedOriginals = new HashSet<string>();
                // Emit interceptors for each call site
                foreach (var (method, syntax, location, invocation) in classGroup)
                {
                    SyntaxNode methodNameNode = null;
                    if (invocation is InvocationExpressionSyntax invocationExpr)
                    {
                        if (invocationExpr.Expression is MemberAccessExpressionSyntax memberAccess)
                        {
                            methodNameNode = memberAccess.Name;
                        }
                        else if (invocationExpr.Expression is IdentifierNameSyntax identifierName)
                        {
                            methodNameNode = identifierName;
                        }
                    }
                    var methodLocation = methodNameNode?.GetLocation() ?? location;
                    var span = methodLocation.GetLineSpan();
                    var filePath = span.Path.Replace("\\", "/");
                    var callLine = span.StartLinePosition.Line + 1;
                    var callColumn = span.StartLinePosition.Character + 1;
                    var methodName = method.Name;
                    var returnType = method.ReturnType.ToDisplayString();
                    var paramListString = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
                    // Add uniqueness to the method name using file, line, and column
                    var uniqueSuffix = $"_{Path.GetFileNameWithoutExtension(filePath)}_{callLine}_{callColumn}";
                    var interceptMethodName = $"{methodName}_Intercepted{uniqueSuffix}";
                    var originalMethodName = $"{methodName}_Original";
                    source += $"        [InterceptsLocation(@\"{filePath}\", {callLine}, {callColumn})]\n";
                    source += $"        public {returnType} {interceptMethodName}({paramListString})\n        {{\n";
                    source += $"            Console.WriteLine(\"Method {methodName} started\");\n";
                    source += $"            try\n            {{\n";
                    var callArgs = string.Join(", ", method.Parameters.Select(p => p.Name));
                    if (returnType != "void")
                        source += $"                return {originalMethodName}({callArgs});\n";
                    else
                        source += $"                {originalMethodName}({callArgs});\n";
                    source += $"            }}\n            catch (Exception ex)\n            {{\n";
                    source += $"                Console.WriteLine(\"Exception in method {methodName}: {{0}}\", ex);\n";
                    source += $"                throw;\n";
                    source += $"            }}\n            finally\n            {{\n";
                    source += $"                Console.WriteLine(\"Method {methodName} ended\");\n";
                    source += $"            }}\n";
                    if (returnType == "void")
                        source += $"            return;\n";
                    source += $"        }}\n";
                    idx++;
                }
                // Emit _Original methods only once per attributed method
                var attributedInClass = attributedMethods.Where(x => SymbolEqualityComparer.Default.Equals(x.symbol.ContainingType, classSymbol));
                foreach (var (method, syntax) in attributedInClass)
                {
                    var methodName = method.Name;
                    if (emittedOriginals.Contains(methodName))
                        continue;
                    emittedOriginals.Add(methodName);
                    var returnType = method.ReturnType.ToDisplayString();
                    var paramListString = string.Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
                    source += $"        private {returnType} {methodName}_Original({paramListString})\n        {{\n";
                    if (syntax.Body != null)
                    {
                        var bodyText = syntax.Body.ToFullString();
                        var indentedBody = string.Join("\n", bodyText.Split('\n').Select(line => "            " + line));
                        source += indentedBody + "\n";
                    }
                    else if (syntax.ExpressionBody != null)
                    {
                        var exprText = syntax.ExpressionBody.ToFullString();
                        source += $"            return {exprText.Substring(2).TrimEnd(';')};\n";
                    }
                    else
                    {
                        source += $"            throw new NotImplementedException(\"Original method body not found.\");\n";
                    }
                    source += $"        }}\n";
                }
                source += "    }\n"; // end class
                source += "}\n"; // end namespace
            }

            context.AddSource("ObservatorInterceptors.g.cs", SourceText.From(source, System.Text.Encoding.UTF8));
        }
    }
}
