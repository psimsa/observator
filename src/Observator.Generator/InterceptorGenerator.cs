using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Observator.Generator
{
    [Generator]
    public class InterceptorGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for now
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // 1. Discover all methods decorated with [ObservatorTrace]
            var attributedMethods = new List<IMethodSymbol>();
            var traceAttributeFullName = "Observator.Generated.ObservatorTraceAttribute";
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var methodDeclarations = syntaxTree.GetRoot()
                    .DescendantNodes()
                    .OfType<MethodDeclarationSyntax>();
                foreach (var methodDecl in methodDeclarations)
                {
                    var methodSymbol = semanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
                    if (methodSymbol == null) continue;
                    foreach (var attr in methodSymbol.GetAttributes())
                    {
                        var attrClass = attr.AttributeClass;
                        if (attrClass == null) continue;
                        var attrName = attrClass.Name;
                        var attrFullName = attrClass.ToDisplayString();
                        if (attrFullName == traceAttributeFullName ||
                            attrName == "ObservatorTraceAttribute" ||
                            attrName == "ObservatorTrace")
                        {
                            attributedMethods.Add(methodSymbol);
                            break;
                        }
                    }
                }
            }

            // 2. For each attributed method, find all call sites
            var callSites = new List<(IMethodSymbol method, Location location, SyntaxNode invocation)>();
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var invocations = syntaxTree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>();
                foreach (var invocation in invocations)
                {
                    var symbolInfo = semanticModel.GetSymbolInfo(invocation);
                    var targetMethod = symbolInfo.Symbol as IMethodSymbol;
                    if (targetMethod == null) continue;
                    foreach (var attributed in attributedMethods)
                    {
                        // Compare by original definition and containing type
                        if (SymbolEqualityComparer.Default.Equals(targetMethod.OriginalDefinition, attributed.OriginalDefinition) &&
                            SymbolEqualityComparer.Default.Equals(targetMethod.ContainingType, attributed.ContainingType))
                        {
                            callSites.Add((attributed, invocation.GetLocation(), invocation));
                            break;
                        }
                    }
                }
            }

            // 3. Output discovered methods and call sites as a comment in generated code
            var source = "// <auto-generated />\n";
            source += $"// Trace attribute full name: {traceAttributeFullName}\n";
            source += $"// Attributed methods found: {attributedMethods.Count}\n";
            source += "// Discovered attributed methods:\n";
            foreach (var method in attributedMethods)
            {
                source += $"// {method.ContainingType.ToDisplayString()}.{method.Name} ({method.Locations.FirstOrDefault()?.GetLineSpan().Path})\n";
            }
            source += $"// Call sites found: {callSites.Count}\n";
            source += "// Discovered call sites:\n";
            foreach (var (method, location, invocation) in callSites)
            {
                var span = location.GetLineSpan();
                source += $"// {method.ContainingType.ToDisplayString()}.{method.Name} called at {span.Path}:{span.StartLinePosition.Line + 1},{span.StartLinePosition.Character + 1}\n";
            }
            source += "\n// Interceptor code generation will be implemented here.\n";

            context.AddSource("ObservatorInterceptors.g.cs", SourceText.From(source, System.Text.Encoding.UTF8));
        }
    }
}
