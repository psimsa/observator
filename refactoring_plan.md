### Refactoring Plan for `InterceptorGenerator.cs`

**Goal:** Improve code readability, maintainability, and adherence to common development patterns by replacing tuples with explicit types, externalizing string constants, and applying the Single Responsibility Principle.

**Steps:**

1.  **Define New Data Structures (Explicit Types):**
    *   **`MethodToInterceptInfo`**: Create a new `struct` or `class` to encapsulate the information about a method targeted for interception. This will replace the `(IMethodSymbol, MethodDeclarationSyntax, IFieldSymbol, Diagnostic)` tuple.
        *   Properties: `IMethodSymbol MethodSymbol`, `MethodDeclarationSyntax MethodDeclaration`, `IFieldSymbol? LoggerField`, `Diagnostic? Diagnostic`.
    *   **`InvocationCallSiteInfo`**: Create a new `struct` or `class` to encapsulate information about an invocation call site. This will replace the `(InvocationExpressionSyntax, IMethodSymbol, InterceptableLocation)` tuple.
        *   Properties: `InvocationExpressionSyntax Invocation`, `IMethodSymbol TargetMethod`, `InterceptableLocation Location`.
    *   **`InterceptorCandidateInfo`**: Create a new `struct` or `class` to represent a combined candidate for interception, linking a method to an invocation. This will replace the `(IMethodSymbol method, MethodDeclarationSyntax syntax, InvocationExpressionSyntax invocation, InterceptableLocation location, IFieldSymbol loggerField)` tuple.
        *   Properties: `IMethodSymbol MethodSymbol`, `MethodDeclarationSyntax MethodDeclaration`, `InvocationExpressionSyntax Invocation`, `InterceptableLocation Location`, `IFieldSymbol? LoggerField`.
    *   **`MethodInterceptorInfo`**: Create a new `struct` or `class` to hold the data needed for generating an interceptor method, specifically for grouping. This will replace the `(IMethodSymbol, InterceptableLocation, IFieldSymbol)` tuple used within the grouped lists.
        *   Properties: `IMethodSymbol MethodSymbol`, `InterceptableLocation Location`, `IFieldSymbol? LoggerField`.

2.  **Externalize String Constants:**
    *   Create a new `static class` named `ObservatorConstants` within the `Observator.Generator` namespace.
    *   Move all hardcoded strings into `public const string` fields within this class. Examples include:
        *   `"Observator.Generated.ObservatorTraceAttribute"`
        *   `"ObservatorTraceAttribute"`
        *   `"ObservatorTrace"`
        *   `"_logger"`, `"logger"`, `"_log"`, `"log"` (logger field names)
        *   `"ILogger"`
        *   `"Microsoft.Extensions.Logging.ILogger"` (logger type prefix)
        *   `"Task"`, `"ValueTask"` (async return types)
        *   `"// <auto-generated />"`
        *   `"using Microsoft.Extensions.Logging;"`
        *   `"file static class Interceptor"`
        *   `"namespace System.Runtime.CompilerServices"`
        *   `"InterceptsLocationAttribute"`
        *   `"Intercepted.{source.GetType().Name}.{methodName}"` (activity name)
        *   `"activity?.SetStatus(System.Diagnostics.ActivityStatusCode.Error, exception.Message);"`
        *   `"activity?.SetStatus(activity.Status == System.Diagnostics.ActivityStatusCode.Unset ? System.Diagnostics.ActivityStatusCode.Ok : activity.Status, activity.StatusDescription)?.Dispose();"`

3.  **Refactor `InterceptorGenerator` for Single Responsibility Principle (SRP):**
    *   **`InterceptorGenerator`**: This class will remain the `IIncrementalGenerator` entry point. Its `Initialize` method will primarily orchestrate the flow by calling dedicated helper classes/methods. It will focus on setting up the `IncrementalGeneratorInitializationContext` and registering the final source output.
    *   **`MethodAnalyzer` (New Top-Level Static Class)**:
        *   Responsibility: Identifying `MethodDeclarationSyntax` nodes with `ObservatorTraceAttribute` and extracting `MethodToInterceptInfo`.
        *   Method: `AnalyzeMethodDeclaration(SyntaxNode node, GeneratorSyntaxContext ctx, CancellationToken ct)`
    *   **`CallSiteAnalyzer` (New Top-Level Static Class)**:
        *   Responsibility: Identifying `InvocationExpressionSyntax` nodes and extracting `InvocationCallSiteInfo`.
        *   Method: `AnalyzeInvocationExpression(SyntaxNode node, GeneratorSyntaxContext ctx, CancellationToken ct)`
    *   **`InterceptorDataProcessor` (New Top-Level Static Class)**:
        *   Responsibility: Combining `MethodToInterceptInfo` and `InvocationCallSiteInfo` to create `InterceptorCandidateInfo` objects, filtering, and grouping them into `Dictionary<string, Dictionary<string, List<MethodInterceptorInfo>>>`. This will encapsulate the complex `foreach` loops and `SymbolEqualityComparer` logic.
        *   Method: `Process(ImmutableArray<MethodToInterceptInfo> attributedMethods, ImmutableArray<InvocationCallSiteInfo> callSites)`
    *   **`SourceCodeGenerator` (New Top-Level Static Class)**:
        *   Responsibility: Generating the final C# source code string based on the processed `MethodInterceptorInfo`. This will contain the `StringBuilder` logic and the `GenerateInterceptorBody_Extension` method (which might also be moved into a private helper within this class).
        *   Method: `Generate(Dictionary<string, Dictionary<string, List<MethodInterceptorInfo>>> interceptorsByNamespace)`

4.  **Update `Initialize` Method Logic:**
    *   The `Initialize` method will be simplified to:
        *   Define `attributedMethods` using `MethodAnalyzer.AnalyzeMethodDeclaration`.
        *   Define `callSites` using `CallSiteAnalyzer.AnalyzeInvocationExpression`.
        *   Combine `attributedMethods.Collect()` and `callSites.Collect()`.
        *   In `RegisterSourceOutput`, call `InterceptorDataProcessor.Process` with the collected data.
        *   Pass the result of `InterceptorDataProcessor.Process` to `SourceCodeGenerator.Generate`.
        *   Add the generated source to the context.

5.  **Error Handling and Diagnostics:**
    *   Ensure that diagnostic reporting is handled appropriately within the `MethodAnalyzer` and passed through the new data structures to `RegisterSourceOutput`.

**Mermaid Diagram for Refactored Flow:**

```mermaid
graph TD
    A[InterceptorGenerator.Initialize] --> B{Method Syntax Provider}
    B --> C[MethodAnalyzer.AnalyzeMethodDeclaration]
    C --> D[MethodToInterceptInfo Stream]

    A --> E{Call Site Syntax Provider}
    E --> F[CallSiteAnalyzer.AnalyzeInvocationExpression]
    F --> G[InvocationCallSiteInfo Stream]

    D -- Collect --> H[Collected MethodToInterceptInfo]
    G -- Collect --> I[Collected InvocationCallSiteInfo]

    H & I --> J[InterceptorDataProcessor.Process]
    J --> K[Grouped MethodInterceptorInfo]

    K --> L[SourceCodeGenerator.Generate]
    L --> M[Final Generated Source Code]

    M --> N[context.RegisterSourceOutput]